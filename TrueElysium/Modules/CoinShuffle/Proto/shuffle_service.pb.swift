// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shuffle_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CoinShuffle_V1_RsaPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Modulus of the RSA public key represented as a big-endian byte array
  var modulus: Data = Data()

  /// Public exponent of the RSA public key represented as a big-endian byte array
  var exponent: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_DecodedOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address of the output
  var address: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Code: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoinShuffle_V1_ShuffleError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoinShuffle_V1_ShuffleError.Code] = [
    .unspecified,
  ]
}

#endif  // swift(>=4.2)

struct CoinShuffle_V1_ShuffleEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: CoinShuffle_V1_ShuffleEvent.OneOf_Body? = nil

  /// 0. An error acquired on one of the steps below
  var error: CoinShuffle_V1_ShuffleError {
    get {
      if case .error(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleError()
    }
    set {body = .error(newValue)}
  }

  /// 1. Receiving of this event means starting of the shuffle process.
  var shuffleInfo: CoinShuffle_V1_ShuffleInfo {
    get {
      if case .shuffleInfo(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleInfo()
    }
    set {body = .shuffleInfo(newValue)}
  }

  /// 2. Receiving of encoded outputs of all participants in the room.
  ///    After that participant using `ShuffleRound` RPC MUST pass decoded
  ///    outputs to continue shuffle process.
  var encodedOutputs: CoinShuffle_V1_EncodedOutputs {
    get {
      if case .encodedOutputs(let v)? = body {return v}
      return CoinShuffle_V1_EncodedOutputs()
    }
    set {body = .encodedOutputs(newValue)}
  }

  /// 3. Receiving decoded outputs of all participants in the room.
  ///    After receiving this event, participant MUST pass signature of
  ///    concatenation of his input and outputs of all other participants
  ///    using `SignShuffleTx` RPC.
  var txSigningOutputs: CoinShuffle_V1_TxSigningOutputs {
    get {
      if case .txSigningOutputs(let v)? = body {return v}
      return CoinShuffle_V1_TxSigningOutputs()
    }
    set {body = .txSigningOutputs(newValue)}
  }

  /// 4. The result transaction hash. The shuffle process is finished.
  var shuffleTxHash: CoinShuffle_V1_ShuffleTxHash {
    get {
      if case .shuffleTxHash(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleTxHash()
    }
    set {body = .shuffleTxHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    /// 0. An error acquired on one of the steps below
    case error(CoinShuffle_V1_ShuffleError)
    /// 1. Receiving of this event means starting of the shuffle process.
    case shuffleInfo(CoinShuffle_V1_ShuffleInfo)
    /// 2. Receiving of encoded outputs of all participants in the room.
    ///    After that participant using `ShuffleRound` RPC MUST pass decoded
    ///    outputs to continue shuffle process.
    case encodedOutputs(CoinShuffle_V1_EncodedOutputs)
    /// 3. Receiving decoded outputs of all participants in the room.
    ///    After receiving this event, participant MUST pass signature of
    ///    concatenation of his input and outputs of all other participants
    ///    using `SignShuffleTx` RPC.
    case txSigningOutputs(CoinShuffle_V1_TxSigningOutputs)
    /// 4. The result transaction hash. The shuffle process is finished.
    case shuffleTxHash(CoinShuffle_V1_ShuffleTxHash)

  #if !swift(>=4.1)
    static func ==(lhs: CoinShuffle_V1_ShuffleEvent.OneOf_Body, rhs: CoinShuffle_V1_ShuffleEvent.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shuffleInfo, .shuffleInfo): return {
        guard case .shuffleInfo(let l) = lhs, case .shuffleInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.encodedOutputs, .encodedOutputs): return {
        guard case .encodedOutputs(let l) = lhs, case .encodedOutputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.txSigningOutputs, .txSigningOutputs): return {
        guard case .txSigningOutputs(let l) = lhs, case .txSigningOutputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shuffleTxHash, .shuffleTxHash): return {
        guard case .shuffleTxHash(let l) = lhs, case .shuffleTxHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CoinShuffle_V1_ShuffleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HEX encoded shuffle participants public keys.
  /// Unique for every user depend on serial number
  var publicKeysList: [CoinShuffle_V1_RsaPublicKey] = []

  /// Token given for accessing room in shuffle process
  var shuffleAccessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_EncodedOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RSA encoded shuffle participants outputs equal to output addresses
  var outputs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_TxSigningOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction outputs for signing
  var outputs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleTxHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Shuffle transaction hash
  var txHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_JoinShuffleRoomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// U256 is a 256-bit unsigned integer.
  var utxoID: Data = Data()

  /// UNIX timestamp in seconds.
  var timestamp: UInt64 = 0

  /// ECDSA signature of concatenated bytes of `utxo_id` and `timestamp`
  ///
  /// `signature = sign(concat(utxo_id, timestamp))`.
  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_JoinShuffleRoomResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roomAccessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_IsReadyForShuffleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_IsReadyForShuffleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ready: Bool = false

  /// New access token to check if room is ready
  var roomAccessToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ConnectShuffleRoomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: CoinShuffle_V1_RsaPublicKey {
    get {return _publicKey ?? CoinShuffle_V1_RsaPublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: CoinShuffle_V1_RsaPublicKey? = nil
}

struct CoinShuffle_V1_ShuffleRoundRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encodedOutputs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleRoundResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_SignShuffleTxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ECDSA Signature of participant's input and list of all outputs
  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_SignShuffleTxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CoinShuffle_V1_RsaPublicKey: @unchecked Sendable {}
extension CoinShuffle_V1_DecodedOutput: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleError: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleError.Code: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleEvent: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleEvent.OneOf_Body: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleInfo: @unchecked Sendable {}
extension CoinShuffle_V1_EncodedOutputs: @unchecked Sendable {}
extension CoinShuffle_V1_TxSigningOutputs: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleTxHash: @unchecked Sendable {}
extension CoinShuffle_V1_JoinShuffleRoomRequest: @unchecked Sendable {}
extension CoinShuffle_V1_JoinShuffleRoomResponse: @unchecked Sendable {}
extension CoinShuffle_V1_IsReadyForShuffleRequest: @unchecked Sendable {}
extension CoinShuffle_V1_IsReadyForShuffleResponse: @unchecked Sendable {}
extension CoinShuffle_V1_ConnectShuffleRoomRequest: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleRoundRequest: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleRoundResponse: @unchecked Sendable {}
extension CoinShuffle_V1_SignShuffleTxRequest: @unchecked Sendable {}
extension CoinShuffle_V1_SignShuffleTxResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coin_shuffle.v1"

extension CoinShuffle_V1_RsaPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RsaPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modulus"),
    2: .same(proto: "exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.modulus) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.exponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modulus.isEmpty {
      try visitor.visitSingularBytesField(value: self.modulus, fieldNumber: 1)
    }
    if !self.exponent.isEmpty {
      try visitor.visitSingularBytesField(value: self.exponent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_RsaPublicKey, rhs: CoinShuffle_V1_RsaPublicKey) -> Bool {
    if lhs.modulus != rhs.modulus {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_DecodedOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodedOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_DecodedOutput, rhs: CoinShuffle_V1_DecodedOutput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleError, rhs: CoinShuffle_V1_ShuffleError) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleError.Code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODE_UNSPECIFIED"),
  ]
}

extension CoinShuffle_V1_ShuffleEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "shuffle_info"),
    3: .standard(proto: "encoded_outputs"),
    4: .standard(proto: "tx_signing_outputs"),
    5: .standard(proto: "shuffle_tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CoinShuffle_V1_ShuffleError?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .error(v)
        }
      }()
      case 2: try {
        var v: CoinShuffle_V1_ShuffleInfo?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .shuffleInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .shuffleInfo(v)
        }
      }()
      case 3: try {
        var v: CoinShuffle_V1_EncodedOutputs?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .encodedOutputs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .encodedOutputs(v)
        }
      }()
      case 4: try {
        var v: CoinShuffle_V1_TxSigningOutputs?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .txSigningOutputs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .txSigningOutputs(v)
        }
      }()
      case 5: try {
        var v: CoinShuffle_V1_ShuffleTxHash?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .shuffleTxHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .shuffleTxHash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .error?: try {
      guard case .error(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .shuffleInfo?: try {
      guard case .shuffleInfo(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .encodedOutputs?: try {
      guard case .encodedOutputs(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .txSigningOutputs?: try {
      guard case .txSigningOutputs(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .shuffleTxHash?: try {
      guard case .shuffleTxHash(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleEvent, rhs: CoinShuffle_V1_ShuffleEvent) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_keys_list"),
    2: .standard(proto: "shuffle_access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publicKeysList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shuffleAccessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeysList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeysList, fieldNumber: 1)
    }
    if !self.shuffleAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.shuffleAccessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleInfo, rhs: CoinShuffle_V1_ShuffleInfo) -> Bool {
    if lhs.publicKeysList != rhs.publicKeysList {return false}
    if lhs.shuffleAccessToken != rhs.shuffleAccessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_EncodedOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncodedOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_EncodedOutputs, rhs: CoinShuffle_V1_EncodedOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_TxSigningOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxSigningOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_TxSigningOutputs, rhs: CoinShuffle_V1_TxSigningOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleTxHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleTxHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleTxHash, rhs: CoinShuffle_V1_ShuffleTxHash) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_JoinShuffleRoomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinShuffleRoomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "utxo_id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.utxoID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxoID.isEmpty {
      try visitor.visitSingularBytesField(value: self.utxoID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_JoinShuffleRoomRequest, rhs: CoinShuffle_V1_JoinShuffleRoomRequest) -> Bool {
    if lhs.utxoID != rhs.utxoID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_JoinShuffleRoomResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinShuffleRoomResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "room_access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roomAccessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roomAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.roomAccessToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_JoinShuffleRoomResponse, rhs: CoinShuffle_V1_JoinShuffleRoomResponse) -> Bool {
    if lhs.roomAccessToken != rhs.roomAccessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_IsReadyForShuffleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyForShuffleRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_IsReadyForShuffleRequest, rhs: CoinShuffle_V1_IsReadyForShuffleRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_IsReadyForShuffleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyForShuffleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ready"),
    2: .standard(proto: "room_access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ready) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roomAccessToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ready != false {
      try visitor.visitSingularBoolField(value: self.ready, fieldNumber: 1)
    }
    if !self.roomAccessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.roomAccessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_IsReadyForShuffleResponse, rhs: CoinShuffle_V1_IsReadyForShuffleResponse) -> Bool {
    if lhs.ready != rhs.ready {return false}
    if lhs.roomAccessToken != rhs.roomAccessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ConnectShuffleRoomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectShuffleRoomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ConnectShuffleRoomRequest, rhs: CoinShuffle_V1_ConnectShuffleRoomRequest) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleRoundRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleRoundRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "encoded_outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.encodedOutputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encodedOutputs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.encodedOutputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleRoundRequest, rhs: CoinShuffle_V1_ShuffleRoundRequest) -> Bool {
    if lhs.encodedOutputs != rhs.encodedOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleRoundResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleRoundResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleRoundResponse, rhs: CoinShuffle_V1_ShuffleRoundResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_SignShuffleTxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignShuffleTxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_SignShuffleTxRequest, rhs: CoinShuffle_V1_SignShuffleTxRequest) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_SignShuffleTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignShuffleTxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_SignShuffleTxResponse, rhs: CoinShuffle_V1_SignShuffleTxResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
