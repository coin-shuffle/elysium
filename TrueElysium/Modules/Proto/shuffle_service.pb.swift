// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shuffle_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CoinShuffle_V1_RoomAccessJWT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header:    base64({"alg":"HS256","typ":"JWT"})
  /// payload:   base64({"room_id":"2ee1deab-40b0-4155-b8ab-b2c253e9f6f6","exp":"123456789"})
  /// signature: base64(HMACSHA256(header.payload, secret))
  /// jwt:       header.payload.signature
  var jwt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_BaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var jwt: CoinShuffle_V1_RoomAccessJWT {
    get {return _jwt ?? CoinShuffle_V1_RoomAccessJWT()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  mutating func clearJwt() {self._jwt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jwt: CoinShuffle_V1_RoomAccessJWT? = nil
}

struct CoinShuffle_V1_JoinShuffleRoomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTXO id that shuffle participant wanna use for shuffle
  var utxo: String = String()

  /// ECDSA Signature of the UTXO ID with the UTXO owner private key
  var sign: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_JoinShuffleRoomResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessJwt: CoinShuffle_V1_RoomAccessJWT {
    get {return _accessJwt ?? CoinShuffle_V1_RoomAccessJWT()}
    set {_accessJwt = newValue}
  }
  /// Returns true if `accessJwt` has been explicitly set.
  var hasAccessJwt: Bool {return self._accessJwt != nil}
  /// Clears the value of `accessJwt`. Subsequent reads from it will return its default value.
  mutating func clearAccessJwt() {self._accessJwt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessJwt: CoinShuffle_V1_RoomAccessJWT? = nil
}

struct CoinShuffle_V1_ConnectShuffleRoomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: CoinShuffle_V1_BaseRequest {
    get {return _base ?? CoinShuffle_V1_BaseRequest()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _base: CoinShuffle_V1_BaseRequest? = nil
}

struct CoinShuffle_V1_ShuffleError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Code: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension CoinShuffle_V1_ShuffleError.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoinShuffle_V1_ShuffleError.Code] = [
    .unspecified,
  ]
}

#endif  // swift(>=4.2)

struct CoinShuffle_V1_ShuffleEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique event identifier
  var id: String = String()

  var body: CoinShuffle_V1_ShuffleEvent.OneOf_Body? = nil

  /// 0. An error acquired on one of the steps below
  var error: CoinShuffle_V1_ShuffleError {
    get {
      if case .error(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleError()
    }
    set {body = .error(newValue)}
  }

  /// 1. Receiving of this event means starting of the shuffle process.
  var shuffleInfo: CoinShuffle_V1_ShuffleInfo {
    get {
      if case .shuffleInfo(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleInfo()
    }
    set {body = .shuffleInfo(newValue)}
  }

  /// 2. Receiving of encoded outputs of all participants in the room.
  ///    After that participant using `ShuffleRound` RPC MUST pass decoded
  ///    outputs to continue shuffle process.
  var encodedOutputs: CoinShuffle_V1_EncodedOutputs {
    get {
      if case .encodedOutputs(let v)? = body {return v}
      return CoinShuffle_V1_EncodedOutputs()
    }
    set {body = .encodedOutputs(newValue)}
  }

  /// 3. Receiving decoded outputs of all participants in the room.
  ///    After receiving this event, participant MUST pass signature of
  ///    concatenation of his input and outputs of all other participants
  ///    using `SignShuffleTx` RPC.
  var txSigningOutputs: CoinShuffle_V1_TxSigningOutputs {
    get {
      if case .txSigningOutputs(let v)? = body {return v}
      return CoinShuffle_V1_TxSigningOutputs()
    }
    set {body = .txSigningOutputs(newValue)}
  }

  /// 4. The result transaction hash. The shuffle process is finished.
  var shuffleTxHash: CoinShuffle_V1_ShuffleTxHash {
    get {
      if case .shuffleTxHash(let v)? = body {return v}
      return CoinShuffle_V1_ShuffleTxHash()
    }
    set {body = .shuffleTxHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    /// 0. An error acquired on one of the steps below
    case error(CoinShuffle_V1_ShuffleError)
    /// 1. Receiving of this event means starting of the shuffle process.
    case shuffleInfo(CoinShuffle_V1_ShuffleInfo)
    /// 2. Receiving of encoded outputs of all participants in the room.
    ///    After that participant using `ShuffleRound` RPC MUST pass decoded
    ///    outputs to continue shuffle process.
    case encodedOutputs(CoinShuffle_V1_EncodedOutputs)
    /// 3. Receiving decoded outputs of all participants in the room.
    ///    After receiving this event, participant MUST pass signature of
    ///    concatenation of his input and outputs of all other participants
    ///    using `SignShuffleTx` RPC.
    case txSigningOutputs(CoinShuffle_V1_TxSigningOutputs)
    /// 4. The result transaction hash. The shuffle process is finished.
    case shuffleTxHash(CoinShuffle_V1_ShuffleTxHash)

  #if !swift(>=4.1)
    static func ==(lhs: CoinShuffle_V1_ShuffleEvent.OneOf_Body, rhs: CoinShuffle_V1_ShuffleEvent.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shuffleInfo, .shuffleInfo): return {
        guard case .shuffleInfo(let l) = lhs, case .shuffleInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.encodedOutputs, .encodedOutputs): return {
        guard case .encodedOutputs(let l) = lhs, case .encodedOutputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.txSigningOutputs, .txSigningOutputs): return {
        guard case .txSigningOutputs(let l) = lhs, case .txSigningOutputs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shuffleTxHash, .shuffleTxHash): return {
        guard case .shuffleTxHash(let l) = lhs, case .shuffleTxHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CoinShuffle_V1_IsReadyForShuffleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: CoinShuffle_V1_BaseRequest {
    get {return _base ?? CoinShuffle_V1_BaseRequest()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _base: CoinShuffle_V1_BaseRequest? = nil
}

struct CoinShuffle_V1_IsReadyForShuffleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ready: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Shuffle participants number
  var participantsNumber: Int32 = 0

  /// Participant's serial number in the shuffle process
  var nodeSerialNumber: Int32 = 0

  /// HEX encoded shuffle participants public keys.
  /// Unique for every user depend on serial number
  var publicKeysList: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_EncodedOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RSA encoded shuffle participants outputs equal to output addresses
  var outputsList: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_TxSigningOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction outputs for signing
  var outputs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleTxHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Shuffle transaction hash
  var txHash: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_DecodedOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HEX encoded shuffle participants outputs; equal to output addresses
  var outputsList: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_ShuffleRoundRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: CoinShuffle_V1_BaseRequest {
    get {return _base ?? CoinShuffle_V1_BaseRequest()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  var encodedOutputs: CoinShuffle_V1_DecodedOutputs {
    get {return _encodedOutputs ?? CoinShuffle_V1_DecodedOutputs()}
    set {_encodedOutputs = newValue}
  }
  /// Returns true if `encodedOutputs` has been explicitly set.
  var hasEncodedOutputs: Bool {return self._encodedOutputs != nil}
  /// Clears the value of `encodedOutputs`. Subsequent reads from it will return its default value.
  mutating func clearEncodedOutputs() {self._encodedOutputs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _base: CoinShuffle_V1_BaseRequest? = nil
  fileprivate var _encodedOutputs: CoinShuffle_V1_DecodedOutputs? = nil
}

struct CoinShuffle_V1_ShuffleRoundResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinShuffle_V1_SignShuffleTxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: CoinShuffle_V1_BaseRequest {
    get {return _base ?? CoinShuffle_V1_BaseRequest()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  /// ECDSA Signature of participant's input and list of all outputs
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _base: CoinShuffle_V1_BaseRequest? = nil
}

struct CoinShuffle_V1_SignShuffleTxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CoinShuffle_V1_RoomAccessJWT: @unchecked Sendable {}
extension CoinShuffle_V1_BaseRequest: @unchecked Sendable {}
extension CoinShuffle_V1_JoinShuffleRoomRequest: @unchecked Sendable {}
extension CoinShuffle_V1_JoinShuffleRoomResponse: @unchecked Sendable {}
extension CoinShuffle_V1_ConnectShuffleRoomRequest: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleError: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleError.Code: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleEvent: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleEvent.OneOf_Body: @unchecked Sendable {}
extension CoinShuffle_V1_IsReadyForShuffleRequest: @unchecked Sendable {}
extension CoinShuffle_V1_IsReadyForShuffleResponse: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleInfo: @unchecked Sendable {}
extension CoinShuffle_V1_EncodedOutputs: @unchecked Sendable {}
extension CoinShuffle_V1_TxSigningOutputs: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleTxHash: @unchecked Sendable {}
extension CoinShuffle_V1_DecodedOutputs: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleRoundRequest: @unchecked Sendable {}
extension CoinShuffle_V1_ShuffleRoundResponse: @unchecked Sendable {}
extension CoinShuffle_V1_SignShuffleTxRequest: @unchecked Sendable {}
extension CoinShuffle_V1_SignShuffleTxResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coin_shuffle.v1"

extension CoinShuffle_V1_RoomAccessJWT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoomAccessJWT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwt.isEmpty {
      try visitor.visitSingularStringField(value: self.jwt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_RoomAccessJWT, rhs: CoinShuffle_V1_RoomAccessJWT) -> Bool {
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_BaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jwt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_BaseRequest, rhs: CoinShuffle_V1_BaseRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._jwt != rhs._jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_JoinShuffleRoomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinShuffleRoomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxo"),
    2: .same(proto: "sign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.utxo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sign) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxo.isEmpty {
      try visitor.visitSingularStringField(value: self.utxo, fieldNumber: 1)
    }
    if !self.sign.isEmpty {
      try visitor.visitSingularStringField(value: self.sign, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_JoinShuffleRoomRequest, rhs: CoinShuffle_V1_JoinShuffleRoomRequest) -> Bool {
    if lhs.utxo != rhs.utxo {return false}
    if lhs.sign != rhs.sign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_JoinShuffleRoomResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinShuffleRoomResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "access_jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accessJwt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessJwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_JoinShuffleRoomResponse, rhs: CoinShuffle_V1_JoinShuffleRoomResponse) -> Bool {
    if lhs._accessJwt != rhs._accessJwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ConnectShuffleRoomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectShuffleRoomRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ConnectShuffleRoomRequest, rhs: CoinShuffle_V1_ConnectShuffleRoomRequest) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleError, rhs: CoinShuffle_V1_ShuffleError) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleError.Code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODE_UNSPECIFIED"),
  ]
}

extension CoinShuffle_V1_ShuffleEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .standard(proto: "shuffle_info"),
    4: .standard(proto: "encoded_outputs"),
    5: .standard(proto: "tx_signing_outputs"),
    6: .standard(proto: "shuffle_tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: CoinShuffle_V1_ShuffleError?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .error(v)
        }
      }()
      case 3: try {
        var v: CoinShuffle_V1_ShuffleInfo?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .shuffleInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .shuffleInfo(v)
        }
      }()
      case 4: try {
        var v: CoinShuffle_V1_EncodedOutputs?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .encodedOutputs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .encodedOutputs(v)
        }
      }()
      case 5: try {
        var v: CoinShuffle_V1_TxSigningOutputs?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .txSigningOutputs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .txSigningOutputs(v)
        }
      }()
      case 6: try {
        var v: CoinShuffle_V1_ShuffleTxHash?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .shuffleTxHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .shuffleTxHash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    switch self.body {
    case .error?: try {
      guard case .error(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .shuffleInfo?: try {
      guard case .shuffleInfo(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .encodedOutputs?: try {
      guard case .encodedOutputs(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .txSigningOutputs?: try {
      guard case .txSigningOutputs(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .shuffleTxHash?: try {
      guard case .shuffleTxHash(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleEvent, rhs: CoinShuffle_V1_ShuffleEvent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_IsReadyForShuffleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyForShuffleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_IsReadyForShuffleRequest, rhs: CoinShuffle_V1_IsReadyForShuffleRequest) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_IsReadyForShuffleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsReadyForShuffleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ready"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ready) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ready != false {
      try visitor.visitSingularBoolField(value: self.ready, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_IsReadyForShuffleResponse, rhs: CoinShuffle_V1_IsReadyForShuffleResponse) -> Bool {
    if lhs.ready != rhs.ready {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participants_number"),
    2: .standard(proto: "node_serial_number"),
    3: .standard(proto: "public_keys_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.participantsNumber) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.nodeSerialNumber) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.publicKeysList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.participantsNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.participantsNumber, fieldNumber: 1)
    }
    if self.nodeSerialNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeSerialNumber, fieldNumber: 2)
    }
    if !self.publicKeysList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.publicKeysList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleInfo, rhs: CoinShuffle_V1_ShuffleInfo) -> Bool {
    if lhs.participantsNumber != rhs.participantsNumber {return false}
    if lhs.nodeSerialNumber != rhs.nodeSerialNumber {return false}
    if lhs.publicKeysList != rhs.publicKeysList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_EncodedOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncodedOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outputs_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.outputsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputsList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputsList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_EncodedOutputs, rhs: CoinShuffle_V1_EncodedOutputs) -> Bool {
    if lhs.outputsList != rhs.outputsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_TxSigningOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxSigningOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_TxSigningOutputs, rhs: CoinShuffle_V1_TxSigningOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleTxHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleTxHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularStringField(value: self.txHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleTxHash, rhs: CoinShuffle_V1_ShuffleTxHash) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_DecodedOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecodedOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outputs_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.outputsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputsList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputsList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_DecodedOutputs, rhs: CoinShuffle_V1_DecodedOutputs) -> Bool {
    if lhs.outputsList != rhs.outputsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleRoundRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleRoundRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .standard(proto: "encoded_outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._encodedOutputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._encodedOutputs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleRoundRequest, rhs: CoinShuffle_V1_ShuffleRoundRequest) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs._encodedOutputs != rhs._encodedOutputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_ShuffleRoundResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShuffleRoundResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_ShuffleRoundResponse, rhs: CoinShuffle_V1_ShuffleRoundResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_SignShuffleTxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignShuffleTxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_SignShuffleTxRequest, rhs: CoinShuffle_V1_SignShuffleTxRequest) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinShuffle_V1_SignShuffleTxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignShuffleTxResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinShuffle_V1_SignShuffleTxResponse, rhs: CoinShuffle_V1_SignShuffleTxResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
